/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var ne = Object.defineProperty;
var pn = Object.getOwnPropertyDescriptor;
var sn = Object.getOwnPropertyNames;
var hn = Object.prototype.hasOwnProperty;
var dn = (e, n) => {
    for (var i in n) ne(e, i, { get: n[i], enumerable: !0 });
  },
  gn = (e, n, i, l) => {
    if ((n && typeof n == "object") || typeof n == "function")
      for (let r of sn(n))
        !hn.call(e, r) &&
          r !== i &&
          ne(e, r, {
            get: () => n[r],
            enumerable: !(l = pn(n, r)) || l.enumerable,
          });
    return e;
  };
var mn = (e) => gn(ne({}, "__esModule", { value: !0 }), e);
var jr = {};
dn(jr, { default: () => ee });
module.exports = mn(jr);
var F = require("obsidian");
var j = require("obsidian"),
  G = class extends j.PluginSettingTab {
    constructor(i, l) {
      super(i, l);
      this.plugin = l;
    }
    display() {
      let { containerEl: i } = this;
      i.empty(),
        i.createEl("h2", { text: "Auto Tag and Link Settings" }),
        new j.Setting(i)
          .setName("Tag Source Folder Path")
          .setDesc(
            'Path to the folder containing your tag files (e.g., "998_Tags"). This folder will be scanned recursively to generate the tag list.'
          )
          .addText((l) =>
            l
              .setPlaceholder("Enter folder path")
              .setValue(this.plugin.settings.tagFolderPath)
              .onChange(async (r) => {
                (this.plugin.settings.tagFolderPath = r),
                  await this.plugin.saveSettings(),
                  await this.plugin.generateTagList();
              })
          ),
        new j.Setting(i)
          .setName("Target Folder for Auto Tagging/Linking")
          .setDesc(
            'Path to the folder where files will be processed for auto-tagging and linking (e.g., "01_Daily Notes"). Leave empty to process the entire vault.'
          )
          .addText((l) =>
            l
              .setPlaceholder("Enter folder path (optional)")
              .setValue(this.plugin.settings.targetFolderPath)
              .onChange(async (r) => {
                (this.plugin.settings.targetFolderPath = r.trim()),
                  await this.plugin.saveSettings();
              })
          );
    }
  };
var I = require("obsidian");
function Ne(e) {
  return typeof e == "undefined" || e === null;
}
function xn(e) {
  return typeof e == "object" && e !== null;
}
function An(e) {
  return Array.isArray(e) ? e : Ne(e) ? [] : [e];
}
function vn(e, n) {
  var i, l, r, t;
  if (n)
    for (t = Object.keys(n), i = 0, l = t.length; i < l; i += 1)
      (r = t[i]), (e[r] = n[r]);
  return e;
}
function yn(e, n) {
  var i = "",
    l;
  for (l = 0; l < n; l += 1) i += e;
  return i;
}
function _n(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
var Cn = Ne,
  wn = xn,
  Fn = An,
  En = yn,
  Sn = _n,
  Tn = vn,
  C = {
    isNothing: Cn,
    isObject: wn,
    toArray: Fn,
    repeat: En,
    isNegativeZero: Sn,
    extend: Tn,
  };
function De(e, n) {
  var i = "",
    l = e.reason || "(unknown reason)";
  return e.mark
    ? (e.mark.name && (i += 'in "' + e.mark.name + '" '),
      (i += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")"),
      !n &&
        e.mark.snippet &&
        (i +=
          `

` + e.mark.snippet),
      l + " " + i)
    : l;
}
function U(e, n) {
  Error.call(this),
    (this.name = "YAMLException"),
    (this.reason = e),
    (this.mark = n),
    (this.message = De(this, !1)),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack || "");
}
U.prototype = Object.create(Error.prototype);
U.prototype.constructor = U;
U.prototype.toString = function (n) {
  return this.name + ": " + De(this, n);
};
var T = U;
function ie(e, n, i, l, r) {
  var t = "",
    o = "",
    u = Math.floor(r / 2) - 1;
  return (
    l - n > u && ((t = " ... "), (n = l - u + t.length)),
    i - l > u && ((o = " ..."), (i = l + u - o.length)),
    {
      str: t + e.slice(n, i).replace(/\t/g, "\u2192") + o,
      pos: l - n + t.length,
    }
  );
}
function re(e, n) {
  return C.repeat(" ", n - e.length) + e;
}
function bn(e, n) {
  if (((n = Object.create(n || null)), !e.buffer)) return null;
  n.maxLength || (n.maxLength = 79),
    typeof n.indent != "number" && (n.indent = 1),
    typeof n.linesBefore != "number" && (n.linesBefore = 3),
    typeof n.linesAfter != "number" && (n.linesAfter = 2);
  for (
    var i = /\r?\n|\r|\0/g, l = [0], r = [], t, o = -1;
    (t = i.exec(e.buffer));

  )
    r.push(t.index),
      l.push(t.index + t[0].length),
      e.position <= t.index && o < 0 && (o = l.length - 2);
  o < 0 && (o = l.length - 1);
  var u = "",
    a,
    c,
    h = Math.min(e.line + n.linesAfter, r.length).toString().length,
    f = n.maxLength - (n.indent + h + 3);
  for (a = 1; a <= n.linesBefore && !(o - a < 0); a++)
    (c = ie(e.buffer, l[o - a], r[o - a], e.position - (l[o] - l[o - a]), f)),
      (u =
        C.repeat(" ", n.indent) +
        re((e.line - a + 1).toString(), h) +
        " | " +
        c.str +
        `
` +
        u);
  for (
    c = ie(e.buffer, l[o], r[o], e.position, f),
      u +=
        C.repeat(" ", n.indent) +
        re((e.line + 1).toString(), h) +
        " | " +
        c.str +
        `
`,
      u +=
        C.repeat("-", n.indent + h + 3 + c.pos) +
        `^
`,
      a = 1;
    a <= n.linesAfter && !(o + a >= r.length);
    a++
  )
    (c = ie(e.buffer, l[o + a], r[o + a], e.position - (l[o] - l[o + a]), f)),
      (u +=
        C.repeat(" ", n.indent) +
        re((e.line + a + 1).toString(), h) +
        " | " +
        c.str +
        `
`);
  return u.replace(/\n$/, "");
}
var Ln = bn,
  In = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases",
  ],
  On = ["scalar", "sequence", "mapping"];
function kn(e) {
  var n = {};
  return (
    e !== null &&
      Object.keys(e).forEach(function (i) {
        e[i].forEach(function (l) {
          n[String(l)] = i;
        });
      }),
    n
  );
}
function Nn(e, n) {
  if (
    ((n = n || {}),
    Object.keys(n).forEach(function (i) {
      if (In.indexOf(i) === -1)
        throw new T(
          'Unknown option "' +
            i +
            '" is met in definition of "' +
            e +
            '" YAML type.'
        );
    }),
    (this.options = n),
    (this.tag = e),
    (this.kind = n.kind || null),
    (this.resolve =
      n.resolve ||
      function () {
        return !0;
      }),
    (this.construct =
      n.construct ||
      function (i) {
        return i;
      }),
    (this.instanceOf = n.instanceOf || null),
    (this.predicate = n.predicate || null),
    (this.represent = n.represent || null),
    (this.representName = n.representName || null),
    (this.defaultStyle = n.defaultStyle || null),
    (this.multi = n.multi || !1),
    (this.styleAliases = kn(n.styleAliases || null)),
    On.indexOf(this.kind) === -1)
  )
    throw new T(
      'Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.'
    );
}
var E = Nn;
function Ae(e, n) {
  var i = [];
  return (
    e[n].forEach(function (l) {
      var r = i.length;
      i.forEach(function (t, o) {
        t.tag === l.tag && t.kind === l.kind && t.multi === l.multi && (r = o);
      }),
        (i[r] = l);
    }),
    i
  );
}
function Dn() {
  var e = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: { scalar: [], sequence: [], mapping: [], fallback: [] },
    },
    n,
    i;
  function l(r) {
    r.multi
      ? (e.multi[r.kind].push(r), e.multi.fallback.push(r))
      : (e[r.kind][r.tag] = e.fallback[r.tag] = r);
  }
  for (n = 0, i = arguments.length; n < i; n += 1) arguments[n].forEach(l);
  return e;
}
function oe(e) {
  return this.extend(e);
}
oe.prototype.extend = function (n) {
  var i = [],
    l = [];
  if (n instanceof E) l.push(n);
  else if (Array.isArray(n)) l = l.concat(n);
  else if (n && (Array.isArray(n.implicit) || Array.isArray(n.explicit)))
    n.implicit && (i = i.concat(n.implicit)),
      n.explicit && (l = l.concat(n.explicit));
  else
    throw new T(
      "Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })"
    );
  i.forEach(function (t) {
    if (!(t instanceof E))
      throw new T(
        "Specified list of YAML types (or a single Type object) contains a non-Type object."
      );
    if (t.loadKind && t.loadKind !== "scalar")
      throw new T(
        "There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported."
      );
    if (t.multi)
      throw new T(
        "There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit."
      );
  }),
    l.forEach(function (t) {
      if (!(t instanceof E))
        throw new T(
          "Specified list of YAML types (or a single Type object) contains a non-Type object."
        );
    });
  var r = Object.create(oe.prototype);
  return (
    (r.implicit = (this.implicit || []).concat(i)),
    (r.explicit = (this.explicit || []).concat(l)),
    (r.compiledImplicit = Ae(r, "implicit")),
    (r.compiledExplicit = Ae(r, "explicit")),
    (r.compiledTypeMap = Dn(r.compiledImplicit, r.compiledExplicit)),
    r
  );
};
var Mn = oe,
  Pn = new E("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function (e) {
      return e !== null ? e : "";
    },
  }),
  Rn = new E("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function (e) {
      return e !== null ? e : [];
    },
  }),
  Bn = new E("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function (e) {
      return e !== null ? e : {};
    },
  }),
  Yn = new Mn({ explicit: [Pn, Rn, Bn] });
function Hn(e) {
  if (e === null) return !0;
  var n = e.length;
  return (
    (n === 1 && e === "~") ||
    (n === 4 && (e === "null" || e === "Null" || e === "NULL"))
  );
}
function jn() {
  return null;
}
function Kn(e) {
  return e === null;
}
var Un = new E("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: Hn,
  construct: jn,
  predicate: Kn,
  represent: {
    canonical: function () {
      return "~";
    },
    lowercase: function () {
      return "null";
    },
    uppercase: function () {
      return "NULL";
    },
    camelcase: function () {
      return "Null";
    },
    empty: function () {
      return "";
    },
  },
  defaultStyle: "lowercase",
});
function $n(e) {
  if (e === null) return !1;
  var n = e.length;
  return (
    (n === 4 && (e === "true" || e === "True" || e === "TRUE")) ||
    (n === 5 && (e === "false" || e === "False" || e === "FALSE"))
  );
}
function Wn(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function qn(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var Gn = new E("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: $n,
  construct: Wn,
  predicate: qn,
  represent: {
    lowercase: function (e) {
      return e ? "true" : "false";
    },
    uppercase: function (e) {
      return e ? "TRUE" : "FALSE";
    },
    camelcase: function (e) {
      return e ? "True" : "False";
    },
  },
  defaultStyle: "lowercase",
});
function Vn(e) {
  return (48 <= e && e <= 57) || (65 <= e && e <= 70) || (97 <= e && e <= 102);
}
function Xn(e) {
  return 48 <= e && e <= 55;
}
function Qn(e) {
  return 48 <= e && e <= 57;
}
function zn(e) {
  if (e === null) return !1;
  var n = e.length,
    i = 0,
    l = !1,
    r;
  if (!n) return !1;
  if (((r = e[i]), (r === "-" || r === "+") && (r = e[++i]), r === "0")) {
    if (i + 1 === n) return !0;
    if (((r = e[++i]), r === "b")) {
      for (i++; i < n; i++)
        if (((r = e[i]), r !== "_")) {
          if (r !== "0" && r !== "1") return !1;
          l = !0;
        }
      return l && r !== "_";
    }
    if (r === "x") {
      for (i++; i < n; i++)
        if (((r = e[i]), r !== "_")) {
          if (!Vn(e.charCodeAt(i))) return !1;
          l = !0;
        }
      return l && r !== "_";
    }
    if (r === "o") {
      for (i++; i < n; i++)
        if (((r = e[i]), r !== "_")) {
          if (!Xn(e.charCodeAt(i))) return !1;
          l = !0;
        }
      return l && r !== "_";
    }
  }
  if (r === "_") return !1;
  for (; i < n; i++)
    if (((r = e[i]), r !== "_")) {
      if (!Qn(e.charCodeAt(i))) return !1;
      l = !0;
    }
  return !(!l || r === "_");
}
function Zn(e) {
  var n = e,
    i = 1,
    l;
  if (
    (n.indexOf("_") !== -1 && (n = n.replace(/_/g, "")),
    (l = n[0]),
    (l === "-" || l === "+") &&
      (l === "-" && (i = -1), (n = n.slice(1)), (l = n[0])),
    n === "0")
  )
    return 0;
  if (l === "0") {
    if (n[1] === "b") return i * parseInt(n.slice(2), 2);
    if (n[1] === "x") return i * parseInt(n.slice(2), 16);
    if (n[1] === "o") return i * parseInt(n.slice(2), 8);
  }
  return i * parseInt(n, 10);
}
function Jn(e) {
  return (
    Object.prototype.toString.call(e) === "[object Number]" &&
    e % 1 === 0 &&
    !C.isNegativeZero(e)
  );
}
var ei = new E("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: zn,
    construct: Zn,
    predicate: Jn,
    represent: {
      binary: function (e) {
        return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
      },
      octal: function (e) {
        return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
      },
      decimal: function (e) {
        return e.toString(10);
      },
      hexadecimal: function (e) {
        return e >= 0
          ? "0x" + e.toString(16).toUpperCase()
          : "-0x" + e.toString(16).toUpperCase().slice(1);
      },
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"],
    },
  }),
  ni = new RegExp(
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
function ii(e) {
  return !(e === null || !ni.test(e) || e[e.length - 1] === "_");
}
function ri(e) {
  var n, i;
  return (
    (n = e.replace(/_/g, "").toLowerCase()),
    (i = n[0] === "-" ? -1 : 1),
    "+-".indexOf(n[0]) >= 0 && (n = n.slice(1)),
    n === ".inf"
      ? i === 1
        ? Number.POSITIVE_INFINITY
        : Number.NEGATIVE_INFINITY
      : n === ".nan"
      ? NaN
      : i * parseFloat(n, 10)
  );
}
var li = /^[-+]?[0-9]+e/;
function oi(e, n) {
  var i;
  if (isNaN(e))
    switch (n) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (n) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (n) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (C.isNegativeZero(e)) return "-0.0";
  return (i = e.toString(10)), li.test(i) ? i.replace("e", ".e") : i;
}
function ti(e) {
  return (
    Object.prototype.toString.call(e) === "[object Number]" &&
    (e % 1 !== 0 || C.isNegativeZero(e))
  );
}
var ui = new E("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: ii,
    construct: ri,
    predicate: ti,
    represent: oi,
    defaultStyle: "lowercase",
  }),
  ai = Yn.extend({ implicit: [Un, Gn, ei, ui] }),
  ci = ai,
  Me = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),
  Pe = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
function fi(e) {
  return e === null ? !1 : Me.exec(e) !== null || Pe.exec(e) !== null;
}
function pi(e) {
  var n,
    i,
    l,
    r,
    t,
    o,
    u,
    a = 0,
    c = null,
    h,
    f,
    p;
  if (((n = Me.exec(e)), n === null && (n = Pe.exec(e)), n === null))
    throw new Error("Date resolve error");
  if (((i = +n[1]), (l = +n[2] - 1), (r = +n[3]), !n[4]))
    return new Date(Date.UTC(i, l, r));
  if (((t = +n[4]), (o = +n[5]), (u = +n[6]), n[7])) {
    for (a = n[7].slice(0, 3); a.length < 3; ) a += "0";
    a = +a;
  }
  return (
    n[9] &&
      ((h = +n[10]),
      (f = +(n[11] || 0)),
      (c = (h * 60 + f) * 6e4),
      n[9] === "-" && (c = -c)),
    (p = new Date(Date.UTC(i, l, r, t, o, u, a))),
    c && p.setTime(p.getTime() - c),
    p
  );
}
function si(e) {
  return e.toISOString();
}
var hi = new E("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: fi,
  construct: pi,
  instanceOf: Date,
  represent: si,
});
function di(e) {
  return e === "<<" || e === null;
}
var gi = new E("tag:yaml.org,2002:merge", { kind: "scalar", resolve: di }),
  fe = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function mi(e) {
  if (e === null) return !1;
  var n,
    i,
    l = 0,
    r = e.length,
    t = fe;
  for (i = 0; i < r; i++)
    if (((n = t.indexOf(e.charAt(i))), !(n > 64))) {
      if (n < 0) return !1;
      l += 6;
    }
  return l % 8 === 0;
}
function xi(e) {
  var n,
    i,
    l = e.replace(/[\r\n=]/g, ""),
    r = l.length,
    t = fe,
    o = 0,
    u = [];
  for (n = 0; n < r; n++)
    n % 4 === 0 &&
      n &&
      (u.push((o >> 16) & 255), u.push((o >> 8) & 255), u.push(o & 255)),
      (o = (o << 6) | t.indexOf(l.charAt(n)));
  return (
    (i = (r % 4) * 6),
    i === 0
      ? (u.push((o >> 16) & 255), u.push((o >> 8) & 255), u.push(o & 255))
      : i === 18
      ? (u.push((o >> 10) & 255), u.push((o >> 2) & 255))
      : i === 12 && u.push((o >> 4) & 255),
    new Uint8Array(u)
  );
}
function Ai(e) {
  var n = "",
    i = 0,
    l,
    r,
    t = e.length,
    o = fe;
  for (l = 0; l < t; l++)
    l % 3 === 0 &&
      l &&
      ((n += o[(i >> 18) & 63]),
      (n += o[(i >> 12) & 63]),
      (n += o[(i >> 6) & 63]),
      (n += o[i & 63])),
      (i = (i << 8) + e[l]);
  return (
    (r = t % 3),
    r === 0
      ? ((n += o[(i >> 18) & 63]),
        (n += o[(i >> 12) & 63]),
        (n += o[(i >> 6) & 63]),
        (n += o[i & 63]))
      : r === 2
      ? ((n += o[(i >> 10) & 63]),
        (n += o[(i >> 4) & 63]),
        (n += o[(i << 2) & 63]),
        (n += o[64]))
      : r === 1 &&
        ((n += o[(i >> 2) & 63]),
        (n += o[(i << 4) & 63]),
        (n += o[64]),
        (n += o[64])),
    n
  );
}
function vi(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var yi = new E("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: mi,
    construct: xi,
    predicate: vi,
    represent: Ai,
  }),
  _i = Object.prototype.hasOwnProperty,
  Ci = Object.prototype.toString;
function wi(e) {
  if (e === null) return !0;
  var n = [],
    i,
    l,
    r,
    t,
    o,
    u = e;
  for (i = 0, l = u.length; i < l; i += 1) {
    if (((r = u[i]), (o = !1), Ci.call(r) !== "[object Object]")) return !1;
    for (t in r)
      if (_i.call(r, t))
        if (!o) o = !0;
        else return !1;
    if (!o) return !1;
    if (n.indexOf(t) === -1) n.push(t);
    else return !1;
  }
  return !0;
}
function Fi(e) {
  return e !== null ? e : [];
}
var Ei = new E("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: wi,
    construct: Fi,
  }),
  Si = Object.prototype.toString;
function Ti(e) {
  if (e === null) return !0;
  var n,
    i,
    l,
    r,
    t,
    o = e;
  for (t = new Array(o.length), n = 0, i = o.length; n < i; n += 1) {
    if (
      ((l = o[n]),
      Si.call(l) !== "[object Object]" ||
        ((r = Object.keys(l)), r.length !== 1))
    )
      return !1;
    t[n] = [r[0], l[r[0]]];
  }
  return !0;
}
function bi(e) {
  if (e === null) return [];
  var n,
    i,
    l,
    r,
    t,
    o = e;
  for (t = new Array(o.length), n = 0, i = o.length; n < i; n += 1)
    (l = o[n]), (r = Object.keys(l)), (t[n] = [r[0], l[r[0]]]);
  return t;
}
var Li = new E("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: Ti,
    construct: bi,
  }),
  Ii = Object.prototype.hasOwnProperty;
function Oi(e) {
  if (e === null) return !0;
  var n,
    i = e;
  for (n in i) if (Ii.call(i, n) && i[n] !== null) return !1;
  return !0;
}
function ki(e) {
  return e !== null ? e : {};
}
var Ni = new E("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: Oi,
    construct: ki,
  }),
  Re = ci.extend({ implicit: [hi, gi], explicit: [yi, Ei, Li, Ni] }),
  N = Object.prototype.hasOwnProperty,
  V = 1,
  Be = 2,
  Ye = 3,
  X = 4,
  le = 1,
  Di = 2,
  ve = 3,
  Mi =
    /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
  Pi = /[\x85\u2028\u2029]/,
  Ri = /[,\[\]\{\}]/,
  He = /^(?:!|!!|![a-z\-]+!)$/i,
  je =
    /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function ye(e) {
  return Object.prototype.toString.call(e);
}
function L(e) {
  return e === 10 || e === 13;
}
function M(e) {
  return e === 9 || e === 32;
}
function b(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function R(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function Bi(e) {
  var n;
  return 48 <= e && e <= 57
    ? e - 48
    : ((n = e | 32), 97 <= n && n <= 102 ? n - 97 + 10 : -1);
}
function Yi(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function Hi(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function _e(e) {
  return e === 48
    ? "\0"
    : e === 97
    ? "\x07"
    : e === 98
    ? "\b"
    : e === 116 || e === 9
    ? "	"
    : e === 110
    ? `
`
    : e === 118
    ? "\v"
    : e === 102
    ? "\f"
    : e === 114
    ? "\r"
    : e === 101
    ? "\x1B"
    : e === 32
    ? " "
    : e === 34
    ? '"'
    : e === 47
    ? "/"
    : e === 92
    ? "\\"
    : e === 78
    ? "\x85"
    : e === 95
    ? "\xA0"
    : e === 76
    ? "\u2028"
    : e === 80
    ? "\u2029"
    : "";
}
function ji(e) {
  return e <= 65535
    ? String.fromCharCode(e)
    : String.fromCharCode(
        ((e - 65536) >> 10) + 55296,
        ((e - 65536) & 1023) + 56320
      );
}
var Ke = new Array(256),
  Ue = new Array(256);
for (D = 0; D < 256; D++) (Ke[D] = _e(D) ? 1 : 0), (Ue[D] = _e(D));
var D;
function Ki(e, n) {
  (this.input = e),
    (this.filename = n.filename || null),
    (this.schema = n.schema || Re),
    (this.onWarning = n.onWarning || null),
    (this.legacy = n.legacy || !1),
    (this.json = n.json || !1),
    (this.listener = n.listener || null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.typeMap = this.schema.compiledTypeMap),
    (this.length = e.length),
    (this.position = 0),
    (this.line = 0),
    (this.lineStart = 0),
    (this.lineIndent = 0),
    (this.firstTabInLine = -1),
    (this.documents = []);
}
function $e(e, n) {
  var i = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart,
  };
  return (i.snippet = Ln(i)), new T(n, i);
}
function d(e, n) {
  throw $e(e, n);
}
function Q(e, n) {
  e.onWarning && e.onWarning.call(null, $e(e, n));
}
var Ce = {
  YAML: function (n, i, l) {
    var r, t, o;
    n.version !== null && d(n, "duplication of %YAML directive"),
      l.length !== 1 && d(n, "YAML directive accepts exactly one argument"),
      (r = /^([0-9]+)\.([0-9]+)$/.exec(l[0])),
      r === null && d(n, "ill-formed argument of the YAML directive"),
      (t = parseInt(r[1], 10)),
      (o = parseInt(r[2], 10)),
      t !== 1 && d(n, "unacceptable YAML version of the document"),
      (n.version = l[0]),
      (n.checkLineBreaks = o < 2),
      o !== 1 && o !== 2 && Q(n, "unsupported YAML version of the document");
  },
  TAG: function (n, i, l) {
    var r, t;
    l.length !== 2 && d(n, "TAG directive accepts exactly two arguments"),
      (r = l[0]),
      (t = l[1]),
      He.test(r) ||
        d(n, "ill-formed tag handle (first argument) of the TAG directive"),
      N.call(n.tagMap, r) &&
        d(
          n,
          'there is a previously declared suffix for "' + r + '" tag handle'
        ),
      je.test(t) ||
        d(n, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      t = decodeURIComponent(t);
    } catch (o) {
      d(n, "tag prefix is malformed: " + t);
    }
    n.tagMap[r] = t;
  },
};
function k(e, n, i, l) {
  var r, t, o, u;
  if (n < i) {
    if (((u = e.input.slice(n, i)), l))
      for (r = 0, t = u.length; r < t; r += 1)
        (o = u.charCodeAt(r)),
          o === 9 ||
            (32 <= o && o <= 1114111) ||
            d(e, "expected valid JSON character");
    else Mi.test(u) && d(e, "the stream contains non-printable characters");
    e.result += u;
  }
}
function we(e, n, i, l) {
  var r, t, o, u;
  for (
    C.isObject(i) ||
      d(e, "cannot merge mappings; the provided source object is unacceptable"),
      r = Object.keys(i),
      o = 0,
      u = r.length;
    o < u;
    o += 1
  )
    (t = r[o]), N.call(n, t) || ((n[t] = i[t]), (l[t] = !0));
}
function B(e, n, i, l, r, t, o, u, a) {
  var c, h;
  if (Array.isArray(r))
    for (r = Array.prototype.slice.call(r), c = 0, h = r.length; c < h; c += 1)
      Array.isArray(r[c]) &&
        d(e, "nested arrays are not supported inside keys"),
        typeof r == "object" &&
          ye(r[c]) === "[object Object]" &&
          (r[c] = "[object Object]");
  if (
    (typeof r == "object" &&
      ye(r) === "[object Object]" &&
      (r = "[object Object]"),
    (r = String(r)),
    n === null && (n = {}),
    l === "tag:yaml.org,2002:merge")
  )
    if (Array.isArray(t))
      for (c = 0, h = t.length; c < h; c += 1) we(e, n, t[c], i);
    else we(e, n, t, i);
  else
    !e.json &&
      !N.call(i, r) &&
      N.call(n, r) &&
      ((e.line = o || e.line),
      (e.lineStart = u || e.lineStart),
      (e.position = a || e.position),
      d(e, "duplicated mapping key")),
      r === "__proto__"
        ? Object.defineProperty(n, r, {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            value: t,
          })
        : (n[r] = t),
      delete i[r];
  return n;
}
function pe(e) {
  var n;
  (n = e.input.charCodeAt(e.position)),
    n === 10
      ? e.position++
      : n === 13
      ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++)
      : d(e, "a line break is expected"),
    (e.line += 1),
    (e.lineStart = e.position),
    (e.firstTabInLine = -1);
}
function _(e, n, i) {
  for (var l = 0, r = e.input.charCodeAt(e.position); r !== 0; ) {
    for (; M(r); )
      r === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position),
        (r = e.input.charCodeAt(++e.position));
    if (n && r === 35)
      do r = e.input.charCodeAt(++e.position);
      while (r !== 10 && r !== 13 && r !== 0);
    if (L(r))
      for (
        pe(e), r = e.input.charCodeAt(e.position), l++, e.lineIndent = 0;
        r === 32;

      )
        e.lineIndent++, (r = e.input.charCodeAt(++e.position));
    else break;
  }
  return (
    i !== -1 && l !== 0 && e.lineIndent < i && Q(e, "deficient indentation"), l
  );
}
function J(e) {
  var n = e.position,
    i;
  return (
    (i = e.input.charCodeAt(n)),
    !!(
      (i === 45 || i === 46) &&
      i === e.input.charCodeAt(n + 1) &&
      i === e.input.charCodeAt(n + 2) &&
      ((n += 3), (i = e.input.charCodeAt(n)), i === 0 || b(i))
    )
  );
}
function se(e, n) {
  n === 1
    ? (e.result += " ")
    : n > 1 &&
      (e.result += C.repeat(
        `
`,
        n - 1
      ));
}
function Ui(e, n, i) {
  var l,
    r,
    t,
    o,
    u,
    a,
    c,
    h,
    f = e.kind,
    p = e.result,
    s;
  if (
    ((s = e.input.charCodeAt(e.position)),
    b(s) ||
      R(s) ||
      s === 35 ||
      s === 38 ||
      s === 42 ||
      s === 33 ||
      s === 124 ||
      s === 62 ||
      s === 39 ||
      s === 34 ||
      s === 37 ||
      s === 64 ||
      s === 96 ||
      ((s === 63 || s === 45) &&
        ((r = e.input.charCodeAt(e.position + 1)), b(r) || (i && R(r)))))
  )
    return !1;
  for (
    e.kind = "scalar", e.result = "", t = o = e.position, u = !1;
    s !== 0;

  ) {
    if (s === 58) {
      if (((r = e.input.charCodeAt(e.position + 1)), b(r) || (i && R(r))))
        break;
    } else if (s === 35) {
      if (((l = e.input.charCodeAt(e.position - 1)), b(l))) break;
    } else {
      if ((e.position === e.lineStart && J(e)) || (i && R(s))) break;
      if (L(s))
        if (
          ((a = e.line),
          (c = e.lineStart),
          (h = e.lineIndent),
          _(e, !1, -1),
          e.lineIndent >= n)
        ) {
          (u = !0), (s = e.input.charCodeAt(e.position));
          continue;
        } else {
          (e.position = o), (e.line = a), (e.lineStart = c), (e.lineIndent = h);
          break;
        }
    }
    u && (k(e, t, o, !1), se(e, e.line - a), (t = o = e.position), (u = !1)),
      M(s) || (o = e.position + 1),
      (s = e.input.charCodeAt(++e.position));
  }
  return k(e, t, o, !1), e.result ? !0 : ((e.kind = f), (e.result = p), !1);
}
function $i(e, n) {
  var i, l, r;
  if (((i = e.input.charCodeAt(e.position)), i !== 39)) return !1;
  for (
    e.kind = "scalar", e.result = "", e.position++, l = r = e.position;
    (i = e.input.charCodeAt(e.position)) !== 0;

  )
    if (i === 39)
      if (
        (k(e, l, e.position, !0),
        (i = e.input.charCodeAt(++e.position)),
        i === 39)
      )
        (l = e.position), e.position++, (r = e.position);
      else return !0;
    else
      L(i)
        ? (k(e, l, r, !0), se(e, _(e, !1, n)), (l = r = e.position))
        : e.position === e.lineStart && J(e)
        ? d(e, "unexpected end of the document within a single quoted scalar")
        : (e.position++, (r = e.position));
  d(e, "unexpected end of the stream within a single quoted scalar");
}
function Wi(e, n) {
  var i, l, r, t, o, u;
  if (((u = e.input.charCodeAt(e.position)), u !== 34)) return !1;
  for (
    e.kind = "scalar", e.result = "", e.position++, i = l = e.position;
    (u = e.input.charCodeAt(e.position)) !== 0;

  ) {
    if (u === 34) return k(e, i, e.position, !0), e.position++, !0;
    if (u === 92) {
      if (
        (k(e, i, e.position, !0), (u = e.input.charCodeAt(++e.position)), L(u))
      )
        _(e, !1, n);
      else if (u < 256 && Ke[u]) (e.result += Ue[u]), e.position++;
      else if ((o = Yi(u)) > 0) {
        for (r = o, t = 0; r > 0; r--)
          (u = e.input.charCodeAt(++e.position)),
            (o = Bi(u)) >= 0
              ? (t = (t << 4) + o)
              : d(e, "expected hexadecimal character");
        (e.result += ji(t)), e.position++;
      } else d(e, "unknown escape sequence");
      i = l = e.position;
    } else
      L(u)
        ? (k(e, i, l, !0), se(e, _(e, !1, n)), (i = l = e.position))
        : e.position === e.lineStart && J(e)
        ? d(e, "unexpected end of the document within a double quoted scalar")
        : (e.position++, (l = e.position));
  }
  d(e, "unexpected end of the stream within a double quoted scalar");
}
function qi(e, n) {
  var i = !0,
    l,
    r,
    t,
    o = e.tag,
    u,
    a = e.anchor,
    c,
    h,
    f,
    p,
    s,
    g = Object.create(null),
    x,
    v,
    w,
    m;
  if (((m = e.input.charCodeAt(e.position)), m === 91))
    (h = 93), (s = !1), (u = []);
  else if (m === 123) (h = 125), (s = !0), (u = {});
  else return !1;
  for (
    e.anchor !== null && (e.anchorMap[e.anchor] = u),
      m = e.input.charCodeAt(++e.position);
    m !== 0;

  ) {
    if ((_(e, !0, n), (m = e.input.charCodeAt(e.position)), m === h))
      return (
        e.position++,
        (e.tag = o),
        (e.anchor = a),
        (e.kind = s ? "mapping" : "sequence"),
        (e.result = u),
        !0
      );
    i
      ? m === 44 && d(e, "expected the node content, but found ','")
      : d(e, "missed comma between flow collection entries"),
      (v = x = w = null),
      (f = p = !1),
      m === 63 &&
        ((c = e.input.charCodeAt(e.position + 1)),
        b(c) && ((f = p = !0), e.position++, _(e, !0, n))),
      (l = e.line),
      (r = e.lineStart),
      (t = e.position),
      Y(e, n, V, !1, !0),
      (v = e.tag),
      (x = e.result),
      _(e, !0, n),
      (m = e.input.charCodeAt(e.position)),
      (p || e.line === l) &&
        m === 58 &&
        ((f = !0),
        (m = e.input.charCodeAt(++e.position)),
        _(e, !0, n),
        Y(e, n, V, !1, !0),
        (w = e.result)),
      s
        ? B(e, u, g, v, x, w, l, r, t)
        : f
        ? u.push(B(e, null, g, v, x, w, l, r, t))
        : u.push(x),
      _(e, !0, n),
      (m = e.input.charCodeAt(e.position)),
      m === 44 ? ((i = !0), (m = e.input.charCodeAt(++e.position))) : (i = !1);
  }
  d(e, "unexpected end of the stream within a flow collection");
}
function Gi(e, n) {
  var i,
    l,
    r = le,
    t = !1,
    o = !1,
    u = n,
    a = 0,
    c = !1,
    h,
    f;
  if (((f = e.input.charCodeAt(e.position)), f === 124)) l = !1;
  else if (f === 62) l = !0;
  else return !1;
  for (e.kind = "scalar", e.result = ""; f !== 0; )
    if (((f = e.input.charCodeAt(++e.position)), f === 43 || f === 45))
      le === r
        ? (r = f === 43 ? ve : Di)
        : d(e, "repeat of a chomping mode identifier");
    else if ((h = Hi(f)) >= 0)
      h === 0
        ? d(
            e,
            "bad explicit indentation width of a block scalar; it cannot be less than one"
          )
        : o
        ? d(e, "repeat of an indentation width identifier")
        : ((u = n + h - 1), (o = !0));
    else break;
  if (M(f)) {
    do f = e.input.charCodeAt(++e.position);
    while (M(f));
    if (f === 35)
      do f = e.input.charCodeAt(++e.position);
      while (!L(f) && f !== 0);
  }
  for (; f !== 0; ) {
    for (
      pe(e), e.lineIndent = 0, f = e.input.charCodeAt(e.position);
      (!o || e.lineIndent < u) && f === 32;

    )
      e.lineIndent++, (f = e.input.charCodeAt(++e.position));
    if ((!o && e.lineIndent > u && (u = e.lineIndent), L(f))) {
      a++;
      continue;
    }
    if (e.lineIndent < u) {
      r === ve
        ? (e.result += C.repeat(
            `
`,
            t ? 1 + a : a
          ))
        : r === le &&
          t &&
          (e.result += `
`);
      break;
    }
    for (
      l
        ? M(f)
          ? ((c = !0),
            (e.result += C.repeat(
              `
`,
              t ? 1 + a : a
            )))
          : c
          ? ((c = !1),
            (e.result += C.repeat(
              `
`,
              a + 1
            )))
          : a === 0
          ? t && (e.result += " ")
          : (e.result += C.repeat(
              `
`,
              a
            ))
        : (e.result += C.repeat(
            `
`,
            t ? 1 + a : a
          )),
        t = !0,
        o = !0,
        a = 0,
        i = e.position;
      !L(f) && f !== 0;

    )
      f = e.input.charCodeAt(++e.position);
    k(e, i, e.position, !1);
  }
  return !0;
}
function Fe(e, n) {
  var i,
    l = e.tag,
    r = e.anchor,
    t = [],
    o,
    u = !1,
    a;
  if (e.firstTabInLine !== -1) return !1;
  for (
    e.anchor !== null && (e.anchorMap[e.anchor] = t),
      a = e.input.charCodeAt(e.position);
    a !== 0 &&
    (e.firstTabInLine !== -1 &&
      ((e.position = e.firstTabInLine),
      d(e, "tab characters must not be used in indentation")),
    !(a !== 45 || ((o = e.input.charCodeAt(e.position + 1)), !b(o))));

  ) {
    if (((u = !0), e.position++, _(e, !0, -1) && e.lineIndent <= n)) {
      t.push(null), (a = e.input.charCodeAt(e.position));
      continue;
    }
    if (
      ((i = e.line),
      Y(e, n, Ye, !1, !0),
      t.push(e.result),
      _(e, !0, -1),
      (a = e.input.charCodeAt(e.position)),
      (e.line === i || e.lineIndent > n) && a !== 0)
    )
      d(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < n) break;
  }
  return u
    ? ((e.tag = l), (e.anchor = r), (e.kind = "sequence"), (e.result = t), !0)
    : !1;
}
function Vi(e, n, i) {
  var l,
    r,
    t,
    o,
    u,
    a,
    c = e.tag,
    h = e.anchor,
    f = {},
    p = Object.create(null),
    s = null,
    g = null,
    x = null,
    v = !1,
    w = !1,
    m;
  if (e.firstTabInLine !== -1) return !1;
  for (
    e.anchor !== null && (e.anchorMap[e.anchor] = f),
      m = e.input.charCodeAt(e.position);
    m !== 0;

  ) {
    if (
      (!v &&
        e.firstTabInLine !== -1 &&
        ((e.position = e.firstTabInLine),
        d(e, "tab characters must not be used in indentation")),
      (l = e.input.charCodeAt(e.position + 1)),
      (t = e.line),
      (m === 63 || m === 58) && b(l))
    )
      m === 63
        ? (v && (B(e, f, p, s, g, null, o, u, a), (s = g = x = null)),
          (w = !0),
          (v = !0),
          (r = !0))
        : v
        ? ((v = !1), (r = !0))
        : d(
            e,
            "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"
          ),
        (e.position += 1),
        (m = l);
    else {
      if (
        ((o = e.line),
        (u = e.lineStart),
        (a = e.position),
        !Y(e, i, Be, !1, !0))
      )
        break;
      if (e.line === t) {
        for (m = e.input.charCodeAt(e.position); M(m); )
          m = e.input.charCodeAt(++e.position);
        if (m === 58)
          (m = e.input.charCodeAt(++e.position)),
            b(m) ||
              d(
                e,
                "a whitespace character is expected after the key-value separator within a block mapping"
              ),
            v && (B(e, f, p, s, g, null, o, u, a), (s = g = x = null)),
            (w = !0),
            (v = !1),
            (r = !1),
            (s = e.tag),
            (g = e.result);
        else if (w)
          d(e, "can not read an implicit mapping pair; a colon is missed");
        else return (e.tag = c), (e.anchor = h), !0;
      } else if (w)
        d(
          e,
          "can not read a block mapping entry; a multiline key may not be an implicit key"
        );
      else return (e.tag = c), (e.anchor = h), !0;
    }
    if (
      ((e.line === t || e.lineIndent > n) &&
        (v && ((o = e.line), (u = e.lineStart), (a = e.position)),
        Y(e, n, X, !0, r) && (v ? (g = e.result) : (x = e.result)),
        v || (B(e, f, p, s, g, x, o, u, a), (s = g = x = null)),
        _(e, !0, -1),
        (m = e.input.charCodeAt(e.position))),
      (e.line === t || e.lineIndent > n) && m !== 0)
    )
      d(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < n) break;
  }
  return (
    v && B(e, f, p, s, g, null, o, u, a),
    w && ((e.tag = c), (e.anchor = h), (e.kind = "mapping"), (e.result = f)),
    w
  );
}
function Xi(e) {
  var n,
    i = !1,
    l = !1,
    r,
    t,
    o;
  if (((o = e.input.charCodeAt(e.position)), o !== 33)) return !1;
  if (
    (e.tag !== null && d(e, "duplication of a tag property"),
    (o = e.input.charCodeAt(++e.position)),
    o === 60
      ? ((i = !0), (o = e.input.charCodeAt(++e.position)))
      : o === 33
      ? ((l = !0), (r = "!!"), (o = e.input.charCodeAt(++e.position)))
      : (r = "!"),
    (n = e.position),
    i)
  ) {
    do o = e.input.charCodeAt(++e.position);
    while (o !== 0 && o !== 62);
    e.position < e.length
      ? ((t = e.input.slice(n, e.position)),
        (o = e.input.charCodeAt(++e.position)))
      : d(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; o !== 0 && !b(o); )
      o === 33 &&
        (l
          ? d(e, "tag suffix cannot contain exclamation marks")
          : ((r = e.input.slice(n - 1, e.position + 1)),
            He.test(r) ||
              d(e, "named tag handle cannot contain such characters"),
            (l = !0),
            (n = e.position + 1))),
        (o = e.input.charCodeAt(++e.position));
    (t = e.input.slice(n, e.position)),
      Ri.test(t) && d(e, "tag suffix cannot contain flow indicator characters");
  }
  t && !je.test(t) && d(e, "tag name cannot contain such characters: " + t);
  try {
    t = decodeURIComponent(t);
  } catch (u) {
    d(e, "tag name is malformed: " + t);
  }
  return (
    i
      ? (e.tag = t)
      : N.call(e.tagMap, r)
      ? (e.tag = e.tagMap[r] + t)
      : r === "!"
      ? (e.tag = "!" + t)
      : r === "!!"
      ? (e.tag = "tag:yaml.org,2002:" + t)
      : d(e, 'undeclared tag handle "' + r + '"'),
    !0
  );
}
function Qi(e) {
  var n, i;
  if (((i = e.input.charCodeAt(e.position)), i !== 38)) return !1;
  for (
    e.anchor !== null && d(e, "duplication of an anchor property"),
      i = e.input.charCodeAt(++e.position),
      n = e.position;
    i !== 0 && !b(i) && !R(i);

  )
    i = e.input.charCodeAt(++e.position);
  return (
    e.position === n &&
      d(e, "name of an anchor node must contain at least one character"),
    (e.anchor = e.input.slice(n, e.position)),
    !0
  );
}
function zi(e) {
  var n, i, l;
  if (((l = e.input.charCodeAt(e.position)), l !== 42)) return !1;
  for (
    l = e.input.charCodeAt(++e.position), n = e.position;
    l !== 0 && !b(l) && !R(l);

  )
    l = e.input.charCodeAt(++e.position);
  return (
    e.position === n &&
      d(e, "name of an alias node must contain at least one character"),
    (i = e.input.slice(n, e.position)),
    N.call(e.anchorMap, i) || d(e, 'unidentified alias "' + i + '"'),
    (e.result = e.anchorMap[i]),
    _(e, !0, -1),
    !0
  );
}
function Y(e, n, i, l, r) {
  var t,
    o,
    u,
    a = 1,
    c = !1,
    h = !1,
    f,
    p,
    s,
    g,
    x,
    v;
  if (
    (e.listener !== null && e.listener("open", e),
    (e.tag = null),
    (e.anchor = null),
    (e.kind = null),
    (e.result = null),
    (t = o = u = X === i || Ye === i),
    l &&
      _(e, !0, -1) &&
      ((c = !0),
      e.lineIndent > n
        ? (a = 1)
        : e.lineIndent === n
        ? (a = 0)
        : e.lineIndent < n && (a = -1)),
    a === 1)
  )
    for (; Xi(e) || Qi(e); )
      _(e, !0, -1)
        ? ((c = !0),
          (u = t),
          e.lineIndent > n
            ? (a = 1)
            : e.lineIndent === n
            ? (a = 0)
            : e.lineIndent < n && (a = -1))
        : (u = !1);
  if (
    (u && (u = c || r),
    (a === 1 || X === i) &&
      (V === i || Be === i ? (x = n) : (x = n + 1),
      (v = e.position - e.lineStart),
      a === 1
        ? (u && (Fe(e, v) || Vi(e, v, x))) || qi(e, x)
          ? (h = !0)
          : ((o && Gi(e, x)) || $i(e, x) || Wi(e, x)
              ? (h = !0)
              : zi(e)
              ? ((h = !0),
                (e.tag !== null || e.anchor !== null) &&
                  d(e, "alias node should not have any properties"))
              : Ui(e, x, V === i) &&
                ((h = !0), e.tag === null && (e.tag = "?")),
            e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
        : a === 0 && (h = u && Fe(e, v))),
    e.tag === null)
  )
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (
      e.result !== null &&
        e.kind !== "scalar" &&
        d(
          e,
          'unacceptable node kind for !<?> tag; it should be "scalar", not "' +
            e.kind +
            '"'
        ),
        f = 0,
        p = e.implicitTypes.length;
      f < p;
      f += 1
    )
      if (((g = e.implicitTypes[f]), g.resolve(e.result))) {
        (e.result = g.construct(e.result)),
          (e.tag = g.tag),
          e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (N.call(e.typeMap[e.kind || "fallback"], e.tag))
      g = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (
        g = null,
          s = e.typeMap.multi[e.kind || "fallback"],
          f = 0,
          p = s.length;
        f < p;
        f += 1
      )
        if (e.tag.slice(0, s[f].tag.length) === s[f].tag) {
          g = s[f];
          break;
        }
    g || d(e, "unknown tag !<" + e.tag + ">"),
      e.result !== null &&
        g.kind !== e.kind &&
        d(
          e,
          "unacceptable node kind for !<" +
            e.tag +
            '> tag; it should be "' +
            g.kind +
            '", not "' +
            e.kind +
            '"'
        ),
      g.resolve(e.result, e.tag)
        ? ((e.result = g.construct(e.result, e.tag)),
          e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
        : d(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return (
    e.listener !== null && e.listener("close", e),
    e.tag !== null || e.anchor !== null || h
  );
}
function Zi(e) {
  var n = e.position,
    i,
    l,
    r,
    t = !1,
    o;
  for (
    e.version = null,
      e.checkLineBreaks = e.legacy,
      e.tagMap = Object.create(null),
      e.anchorMap = Object.create(null);
    (o = e.input.charCodeAt(e.position)) !== 0 &&
    (_(e, !0, -1),
    (o = e.input.charCodeAt(e.position)),
    !(e.lineIndent > 0 || o !== 37));

  ) {
    for (
      t = !0, o = e.input.charCodeAt(++e.position), i = e.position;
      o !== 0 && !b(o);

    )
      o = e.input.charCodeAt(++e.position);
    for (
      l = e.input.slice(i, e.position),
        r = [],
        l.length < 1 &&
          d(e, "directive name must not be less than one character in length");
      o !== 0;

    ) {
      for (; M(o); ) o = e.input.charCodeAt(++e.position);
      if (o === 35) {
        do o = e.input.charCodeAt(++e.position);
        while (o !== 0 && !L(o));
        break;
      }
      if (L(o)) break;
      for (i = e.position; o !== 0 && !b(o); )
        o = e.input.charCodeAt(++e.position);
      r.push(e.input.slice(i, e.position));
    }
    o !== 0 && pe(e),
      N.call(Ce, l)
        ? Ce[l](e, l, r)
        : Q(e, 'unknown document directive "' + l + '"');
  }
  if (
    (_(e, !0, -1),
    e.lineIndent === 0 &&
    e.input.charCodeAt(e.position) === 45 &&
    e.input.charCodeAt(e.position + 1) === 45 &&
    e.input.charCodeAt(e.position + 2) === 45
      ? ((e.position += 3), _(e, !0, -1))
      : t && d(e, "directives end mark is expected"),
    Y(e, e.lineIndent - 1, X, !1, !0),
    _(e, !0, -1),
    e.checkLineBreaks &&
      Pi.test(e.input.slice(n, e.position)) &&
      Q(e, "non-ASCII line breaks are interpreted as content"),
    e.documents.push(e.result),
    e.position === e.lineStart && J(e))
  ) {
    e.input.charCodeAt(e.position) === 46 && ((e.position += 3), _(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1)
    d(e, "end of the stream or a document separator is expected");
  else return;
}
function We(e, n) {
  (e = String(e)),
    (n = n || {}),
    e.length !== 0 &&
      (e.charCodeAt(e.length - 1) !== 10 &&
        e.charCodeAt(e.length - 1) !== 13 &&
        (e += `
`),
      e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var i = new Ki(e, n),
    l = e.indexOf("\0");
  for (
    l !== -1 && ((i.position = l), d(i, "null byte is not allowed in input")),
      i.input += "\0";
    i.input.charCodeAt(i.position) === 32;

  )
    (i.lineIndent += 1), (i.position += 1);
  for (; i.position < i.length - 1; ) Zi(i);
  return i.documents;
}
function Ji(e, n, i) {
  n !== null &&
    typeof n == "object" &&
    typeof i == "undefined" &&
    ((i = n), (n = null));
  var l = We(e, i);
  if (typeof n != "function") return l;
  for (var r = 0, t = l.length; r < t; r += 1) n(l[r]);
}
function er(e, n) {
  var i = We(e, n);
  if (i.length !== 0) {
    if (i.length === 1) return i[0];
    throw new T("expected a single document in the stream, but found more");
  }
}
var nr = Ji,
  ir = er,
  qe = { loadAll: nr, load: ir },
  Ge = Object.prototype.toString,
  Ve = Object.prototype.hasOwnProperty,
  he = 65279,
  rr = 9,
  $ = 10,
  lr = 13,
  or = 32,
  tr = 33,
  ur = 34,
  te = 35,
  ar = 37,
  cr = 38,
  fr = 39,
  pr = 42,
  Xe = 44,
  sr = 45,
  z = 58,
  hr = 61,
  dr = 62,
  gr = 63,
  mr = 64,
  Qe = 91,
  ze = 93,
  xr = 96,
  Ze = 123,
  Ar = 124,
  Je = 125,
  S = {};
S[0] = "\\0";
S[7] = "\\a";
S[8] = "\\b";
S[9] = "\\t";
S[10] = "\\n";
S[11] = "\\v";
S[12] = "\\f";
S[13] = "\\r";
S[27] = "\\e";
S[34] = '\\"';
S[92] = "\\\\";
S[133] = "\\N";
S[160] = "\\_";
S[8232] = "\\L";
S[8233] = "\\P";
var vr = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF",
  ],
  yr = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function _r(e, n) {
  var i, l, r, t, o, u, a;
  if (n === null) return {};
  for (i = {}, l = Object.keys(n), r = 0, t = l.length; r < t; r += 1)
    (o = l[r]),
      (u = String(n[o])),
      o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)),
      (a = e.compiledTypeMap.fallback[o]),
      a && Ve.call(a.styleAliases, u) && (u = a.styleAliases[u]),
      (i[o] = u);
  return i;
}
function Cr(e) {
  var n, i, l;
  if (((n = e.toString(16).toUpperCase()), e <= 255)) (i = "x"), (l = 2);
  else if (e <= 65535) (i = "u"), (l = 4);
  else if (e <= 4294967295) (i = "U"), (l = 8);
  else
    throw new T(
      "code point within a string may not be greater than 0xFFFFFFFF"
    );
  return "\\" + i + C.repeat("0", l - n.length) + n;
}
var wr = 1,
  W = 2;
function Fr(e) {
  (this.schema = e.schema || Re),
    (this.indent = Math.max(1, e.indent || 2)),
    (this.noArrayIndent = e.noArrayIndent || !1),
    (this.skipInvalid = e.skipInvalid || !1),
    (this.flowLevel = C.isNothing(e.flowLevel) ? -1 : e.flowLevel),
    (this.styleMap = _r(this.schema, e.styles || null)),
    (this.sortKeys = e.sortKeys || !1),
    (this.lineWidth = e.lineWidth || 80),
    (this.noRefs = e.noRefs || !1),
    (this.noCompatMode = e.noCompatMode || !1),
    (this.condenseFlow = e.condenseFlow || !1),
    (this.quotingType = e.quotingType === '"' ? W : wr),
    (this.forceQuotes = e.forceQuotes || !1),
    (this.replacer = typeof e.replacer == "function" ? e.replacer : null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.explicitTypes = this.schema.compiledExplicit),
    (this.tag = null),
    (this.result = ""),
    (this.duplicates = []),
    (this.usedDuplicates = null);
}
function Ee(e, n) {
  for (
    var i = C.repeat(" ", n), l = 0, r = -1, t = "", o, u = e.length;
    l < u;

  )
    (r = e.indexOf(
      `
`,
      l
    )),
      r === -1
        ? ((o = e.slice(l)), (l = u))
        : ((o = e.slice(l, r + 1)), (l = r + 1)),
      o.length &&
        o !==
          `
` &&
        (t += i),
      (t += o);
  return t;
}
function ue(e, n) {
  return (
    `
` + C.repeat(" ", e.indent * n)
  );
}
function Er(e, n) {
  var i, l, r;
  for (i = 0, l = e.implicitTypes.length; i < l; i += 1)
    if (((r = e.implicitTypes[i]), r.resolve(n))) return !0;
  return !1;
}
function Z(e) {
  return e === or || e === rr;
}
function q(e) {
  return (
    (32 <= e && e <= 126) ||
    (161 <= e && e <= 55295 && e !== 8232 && e !== 8233) ||
    (57344 <= e && e <= 65533 && e !== he) ||
    (65536 <= e && e <= 1114111)
  );
}
function Se(e) {
  return q(e) && e !== he && e !== lr && e !== $;
}
function Te(e, n, i) {
  var l = Se(e),
    r = l && !Z(e);
  return (
    ((i ? l : l && e !== Xe && e !== Qe && e !== ze && e !== Ze && e !== Je) &&
      e !== te &&
      !(n === z && !r)) ||
    (Se(n) && !Z(n) && e === te) ||
    (n === z && r)
  );
}
function Sr(e) {
  return (
    q(e) &&
    e !== he &&
    !Z(e) &&
    e !== sr &&
    e !== gr &&
    e !== z &&
    e !== Xe &&
    e !== Qe &&
    e !== ze &&
    e !== Ze &&
    e !== Je &&
    e !== te &&
    e !== cr &&
    e !== pr &&
    e !== tr &&
    e !== Ar &&
    e !== hr &&
    e !== dr &&
    e !== fr &&
    e !== ur &&
    e !== ar &&
    e !== mr &&
    e !== xr
  );
}
function Tr(e) {
  return !Z(e) && e !== z;
}
function K(e, n) {
  var i = e.charCodeAt(n),
    l;
  return i >= 55296 &&
    i <= 56319 &&
    n + 1 < e.length &&
    ((l = e.charCodeAt(n + 1)), l >= 56320 && l <= 57343)
    ? (i - 55296) * 1024 + l - 56320 + 65536
    : i;
}
function en(e) {
  var n = /^\n* /;
  return n.test(e);
}
var nn = 1,
  ae = 2,
  rn = 3,
  ln = 4,
  P = 5;
function br(e, n, i, l, r, t, o, u) {
  var a,
    c = 0,
    h = null,
    f = !1,
    p = !1,
    s = l !== -1,
    g = -1,
    x = Sr(K(e, 0)) && Tr(K(e, e.length - 1));
  if (n || o)
    for (a = 0; a < e.length; c >= 65536 ? (a += 2) : a++) {
      if (((c = K(e, a)), !q(c))) return P;
      (x = x && Te(c, h, u)), (h = c);
    }
  else {
    for (a = 0; a < e.length; c >= 65536 ? (a += 2) : a++) {
      if (((c = K(e, a)), c === $))
        (f = !0),
          s && ((p = p || (a - g - 1 > l && e[g + 1] !== " ")), (g = a));
      else if (!q(c)) return P;
      (x = x && Te(c, h, u)), (h = c);
    }
    p = p || (s && a - g - 1 > l && e[g + 1] !== " ");
  }
  return !f && !p
    ? x && !o && !r(e)
      ? nn
      : t === W
      ? P
      : ae
    : i > 9 && en(e)
    ? P
    : o
    ? t === W
      ? P
      : ae
    : p
    ? ln
    : rn;
}
function Lr(e, n, i, l, r) {
  e.dump = (function () {
    if (n.length === 0) return e.quotingType === W ? '""' : "''";
    if (!e.noCompatMode && (vr.indexOf(n) !== -1 || yr.test(n)))
      return e.quotingType === W ? '"' + n + '"' : "'" + n + "'";
    var t = e.indent * Math.max(1, i),
      o =
        e.lineWidth === -1
          ? -1
          : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - t),
      u = l || (e.flowLevel > -1 && i >= e.flowLevel);
    function a(c) {
      return Er(e, c);
    }
    switch (br(n, u, e.indent, o, a, e.quotingType, e.forceQuotes && !l, r)) {
      case nn:
        return n;
      case ae:
        return "'" + n.replace(/'/g, "''") + "'";
      case rn:
        return "|" + be(n, e.indent) + Le(Ee(n, t));
      case ln:
        return ">" + be(n, e.indent) + Le(Ee(Ir(n, o), t));
      case P:
        return '"' + Or(n) + '"';
      default:
        throw new T("impossible error: invalid scalar style");
    }
  })();
}
function be(e, n) {
  var i = en(e) ? String(n) : "",
    l =
      e[e.length - 1] ===
      `
`,
    r =
      l &&
      (e[e.length - 2] ===
        `
` ||
        e ===
          `
`),
    t = r ? "+" : l ? "" : "-";
  return (
    i +
    t +
    `
`
  );
}
function Le(e) {
  return e[e.length - 1] ===
    `
`
    ? e.slice(0, -1)
    : e;
}
function Ir(e, n) {
  for (
    var i = /(\n+)([^\n]*)/g,
      l = (function () {
        var c = e.indexOf(`
`);
        return (
          (c = c !== -1 ? c : e.length), (i.lastIndex = c), Ie(e.slice(0, c), n)
        );
      })(),
      r =
        e[0] ===
          `
` || e[0] === " ",
      t,
      o;
    (o = i.exec(e));

  ) {
    var u = o[1],
      a = o[2];
    (t = a[0] === " "),
      (l +=
        u +
        (!r && !t && a !== ""
          ? `
`
          : "") +
        Ie(a, n)),
      (r = t);
  }
  return l;
}
function Ie(e, n) {
  if (e === "" || e[0] === " ") return e;
  for (var i = / [^ ]/g, l, r = 0, t, o = 0, u = 0, a = ""; (l = i.exec(e)); )
    (u = l.index),
      u - r > n &&
        ((t = o > r ? o : u),
        (a +=
          `
` + e.slice(r, t)),
        (r = t + 1)),
      (o = u);
  return (
    (a += `
`),
    e.length - r > n && o > r
      ? (a +=
          e.slice(r, o) +
          `
` +
          e.slice(o + 1))
      : (a += e.slice(r)),
    a.slice(1)
  );
}
function Or(e) {
  for (var n = "", i = 0, l, r = 0; r < e.length; i >= 65536 ? (r += 2) : r++)
    (i = K(e, r)),
      (l = S[i]),
      !l && q(i)
        ? ((n += e[r]), i >= 65536 && (n += e[r + 1]))
        : (n += l || Cr(i));
  return n;
}
function kr(e, n, i) {
  var l = "",
    r = e.tag,
    t,
    o,
    u;
  for (t = 0, o = i.length; t < o; t += 1)
    (u = i[t]),
      e.replacer && (u = e.replacer.call(i, String(t), u)),
      (O(e, n, u, !1, !1) ||
        (typeof u == "undefined" && O(e, n, null, !1, !1))) &&
        (l !== "" && (l += "," + (e.condenseFlow ? "" : " ")), (l += e.dump));
  (e.tag = r), (e.dump = "[" + l + "]");
}
function Oe(e, n, i, l) {
  var r = "",
    t = e.tag,
    o,
    u,
    a;
  for (o = 0, u = i.length; o < u; o += 1)
    (a = i[o]),
      e.replacer && (a = e.replacer.call(i, String(o), a)),
      (O(e, n + 1, a, !0, !0, !1, !0) ||
        (typeof a == "undefined" && O(e, n + 1, null, !0, !0, !1, !0))) &&
        ((!l || r !== "") && (r += ue(e, n)),
        e.dump && $ === e.dump.charCodeAt(0) ? (r += "-") : (r += "- "),
        (r += e.dump));
  (e.tag = t), (e.dump = r || "[]");
}
function Nr(e, n, i) {
  var l = "",
    r = e.tag,
    t = Object.keys(i),
    o,
    u,
    a,
    c,
    h;
  for (o = 0, u = t.length; o < u; o += 1)
    (h = ""),
      l !== "" && (h += ", "),
      e.condenseFlow && (h += '"'),
      (a = t[o]),
      (c = i[a]),
      e.replacer && (c = e.replacer.call(i, a, c)),
      O(e, n, a, !1, !1) &&
        (e.dump.length > 1024 && (h += "? "),
        (h +=
          e.dump +
          (e.condenseFlow ? '"' : "") +
          ":" +
          (e.condenseFlow ? "" : " ")),
        O(e, n, c, !1, !1) && ((h += e.dump), (l += h)));
  (e.tag = r), (e.dump = "{" + l + "}");
}
function Dr(e, n, i, l) {
  var r = "",
    t = e.tag,
    o = Object.keys(i),
    u,
    a,
    c,
    h,
    f,
    p;
  if (e.sortKeys === !0) o.sort();
  else if (typeof e.sortKeys == "function") o.sort(e.sortKeys);
  else if (e.sortKeys) throw new T("sortKeys must be a boolean or a function");
  for (u = 0, a = o.length; u < a; u += 1)
    (p = ""),
      (!l || r !== "") && (p += ue(e, n)),
      (c = o[u]),
      (h = i[c]),
      e.replacer && (h = e.replacer.call(i, c, h)),
      O(e, n + 1, c, !0, !0, !0) &&
        ((f =
          (e.tag !== null && e.tag !== "?") ||
          (e.dump && e.dump.length > 1024)),
        f && (e.dump && $ === e.dump.charCodeAt(0) ? (p += "?") : (p += "? ")),
        (p += e.dump),
        f && (p += ue(e, n)),
        O(e, n + 1, h, !0, f) &&
          (e.dump && $ === e.dump.charCodeAt(0) ? (p += ":") : (p += ": "),
          (p += e.dump),
          (r += p)));
  (e.tag = t), (e.dump = r || "{}");
}
function ke(e, n, i) {
  var l, r, t, o, u, a;
  for (
    r = i ? e.explicitTypes : e.implicitTypes, t = 0, o = r.length;
    t < o;
    t += 1
  )
    if (
      ((u = r[t]),
      (u.instanceOf || u.predicate) &&
        (!u.instanceOf ||
          (typeof n == "object" && n instanceof u.instanceOf)) &&
        (!u.predicate || u.predicate(n)))
    ) {
      if (
        (i
          ? u.multi && u.representName
            ? (e.tag = u.representName(n))
            : (e.tag = u.tag)
          : (e.tag = "?"),
        u.represent)
      ) {
        if (
          ((a = e.styleMap[u.tag] || u.defaultStyle),
          Ge.call(u.represent) === "[object Function]")
        )
          l = u.represent(n, a);
        else if (Ve.call(u.represent, a)) l = u.represent[a](n, a);
        else
          throw new T(
            "!<" + u.tag + '> tag resolver accepts not "' + a + '" style'
          );
        e.dump = l;
      }
      return !0;
    }
  return !1;
}
function O(e, n, i, l, r, t, o) {
  (e.tag = null), (e.dump = i), ke(e, i, !1) || ke(e, i, !0);
  var u = Ge.call(e.dump),
    a = l,
    c;
  l && (l = e.flowLevel < 0 || e.flowLevel > n);
  var h = u === "[object Object]" || u === "[object Array]",
    f,
    p;
  if (
    (h && ((f = e.duplicates.indexOf(i)), (p = f !== -1)),
    ((e.tag !== null && e.tag !== "?") || p || (e.indent !== 2 && n > 0)) &&
      (r = !1),
    p && e.usedDuplicates[f])
  )
    e.dump = "*ref_" + f;
  else {
    if (
      (h && p && !e.usedDuplicates[f] && (e.usedDuplicates[f] = !0),
      u === "[object Object]")
    )
      l && Object.keys(e.dump).length !== 0
        ? (Dr(e, n, e.dump, r), p && (e.dump = "&ref_" + f + e.dump))
        : (Nr(e, n, e.dump), p && (e.dump = "&ref_" + f + " " + e.dump));
    else if (u === "[object Array]")
      l && e.dump.length !== 0
        ? (e.noArrayIndent && !o && n > 0
            ? Oe(e, n - 1, e.dump, r)
            : Oe(e, n, e.dump, r),
          p && (e.dump = "&ref_" + f + e.dump))
        : (kr(e, n, e.dump), p && (e.dump = "&ref_" + f + " " + e.dump));
    else if (u === "[object String]") e.tag !== "?" && Lr(e, e.dump, n, t, a);
    else {
      if (u === "[object Undefined]") return !1;
      if (e.skipInvalid) return !1;
      throw new T("unacceptable kind of an object to dump " + u);
    }
    e.tag !== null &&
      e.tag !== "?" &&
      ((c = encodeURI(e.tag[0] === "!" ? e.tag.slice(1) : e.tag).replace(
        /!/g,
        "%21"
      )),
      e.tag[0] === "!"
        ? (c = "!" + c)
        : c.slice(0, 18) === "tag:yaml.org,2002:"
        ? (c = "!!" + c.slice(18))
        : (c = "!<" + c + ">"),
      (e.dump = c + " " + e.dump));
  }
  return !0;
}
function Mr(e, n) {
  var i = [],
    l = [],
    r,
    t;
  for (ce(e, i, l), r = 0, t = l.length; r < t; r += 1)
    n.duplicates.push(i[l[r]]);
  n.usedDuplicates = new Array(t);
}
function ce(e, n, i) {
  var l, r, t;
  if (e !== null && typeof e == "object")
    if (((r = n.indexOf(e)), r !== -1)) i.indexOf(r) === -1 && i.push(r);
    else if ((n.push(e), Array.isArray(e)))
      for (r = 0, t = e.length; r < t; r += 1) ce(e[r], n, i);
    else
      for (l = Object.keys(e), r = 0, t = l.length; r < t; r += 1)
        ce(e[l[r]], n, i);
}
function Pr(e, n) {
  n = n || {};
  var i = new Fr(n);
  i.noRefs || Mr(e, i);
  var l = e;
  return (
    i.replacer && (l = i.replacer.call({ "": l }, "", l)),
    O(i, 0, l, !0, !0)
      ? i.dump +
        `
`
      : ""
  );
}
var Rr = Pr,
  Br = { dump: Rr };
function de(e, n) {
  return function () {
    throw new Error(
      "Function yaml." +
        e +
        " is removed in js-yaml 4. Use yaml." +
        n +
        " instead, which is now safe by default."
    );
  };
}
var on = qe.load,
  qr = qe.loadAll,
  tn = Br.dump;
var Gr = de("safeLoad", "load"),
  Vr = de("safeLoadAll", "loadAll"),
  Xr = de("safeDump", "dump");
function un(e) {
  let n = e.split("---");
  if (n.length > 2 && n[0].trim() === "")
    try {
      return {
        frontmatter: on(n[1]) || {},
        contentWithoutFrontmatter: n.slice(2).join("---").trim(),
      };
    } catch (i) {
      return (
        console.error("Failed to parse frontmatter:", i),
        { frontmatter: {}, contentWithoutFrontmatter: e }
      );
    }
  return { frontmatter: {}, contentWithoutFrontmatter: e };
}
function an(e) {
  try {
    return tn(e);
  } catch (n) {
    return console.error("Failed to dump frontmatter:", n), "";
  }
}
function H(e) {
  return e.toLowerCase().trim();
}
function ge(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
async function me(e, n, i, l) {
  let r = [];
  if (i) r.push(i);
  else if (l) {
    let o = e.vault.getAbstractFileByPath(l);
    if (o instanceof I.TFolder) await cn(o, r);
    else {
      new I.Notice(`Target folder "${l}" not found. Processing skipped.`, 5e3);
      return;
    }
  } else r = e.vault.getMarkdownFiles();
  if (r.length === 0) {
    new I.Notice(
      "No Markdown files found to process in the specified location.",
      3e3
    );
    return;
  }
  let t = 0;
  for (let o of r)
    if (!o.path.startsWith("998_Tags"))
      try {
        let u = await e.vault.read(o),
          { frontmatter: a, contentWithoutFrontmatter: c } = un(u),
          h = Array.isArray(a.tags) ? a.tags : [],
          f = new Set();
        h.forEach((y) => f.add(H(y)));
        let p = c,
          s = c,
          g = [],
          x = 0;
        (p = p.replace(/```[\s\S]*?```/g, (y) => {
          let A = `__MASKED_CODEBLOCK_${x++}__`;
          return g.push(y), A;
        })),
          (p = p.replace(/`[^`\n]*?`/g, (y) => {
            let A = `__MASKED_INLINECODE_${x++}__`;
            return g.push(y), A;
          })),
          (p = p.replace(/``/g, (y) => {
            let A = `__MASKED_INLINECODE_${x++}__`;
            return g.push(y), A;
          })),
          (p = p.replace(/\[\[[^\]]*?\]\]/g, (y) => {
            let A = `__MASKED_OBSIDIANLINK_${x++}__`;
            return g.push(y), A;
          })),
          (p = p.replace(/!?\[(?:[^[\]]|\[[^\]]*\])*\]\([^)]*\)/g, (y) => {
            let A = `__MASKED_MARKDOWNLINK_${x++}__`;
            return g.push(y), A;
          }));
        for (let y of n) {
          let A = new RegExp(`\\b${ge(y)}\\b`, "gi");
          p.match(A) && f.add(y);
        }
        a.tags = Array.from(f).sort();
        let v = new Map(),
          w = 0;
        (s = s.replace(/```[\s\S]*?```/g, (y) => {
          let A = `__LINK_EXCL_CODEBLOCK_${w++}__`;
          return v.set(A, y), A;
        })),
          (s = s.replace(/`[^`\n]*?`/g, (y) => {
            let A = `__LINK_EXCL_INLINECODE_${w++}__`;
            return v.set(A, y), A;
          })),
          (s = s.replace(/``/g, (y) => {
            let A = `__LINK_EXCL_INLINECODE_${w++}__`;
            return v.set(A, y), A;
          })),
          (s = s.replace(/\[\[[^\]]*?\]\]/g, (y) => {
            let A = `__LINK_EXCL_OBSIDIANLINK_${w++}__`;
            return v.set(A, y), A;
          })),
          (s = s.replace(/!?\[(?:[^[\]]|\[[^\]]*\])*\]\([^)]*\)/g, (y) => {
            let A = `__LINK_EXCL_MARKDOWNLINK_${w++}__`;
            return v.set(A, y), A;
          }));
        let m = s;
        for (let y of n) {
          let A = new RegExp(`\\b${ge(y)}\\b`, "gi");
          m = m.replace(A, (fn) => `[[${fn}]]`);
        }
        v.forEach((y, A) => {
          m = m.replace(A, y);
        });
        let xe = `---
${an(a)}---
${m.trim()}
`;
        u !== xe && (await e.vault.modify(o, xe), t++);
      } catch (u) {
        console.error(`Error processing file ${o.path}:`, u),
          new I.Notice(
            `Failed to process ${o.basename}. See console for details.`,
            5e3
          );
      }
  new I.Notice(`Processed ${t} files successfully.`);
}
async function cn(e, n) {
  for (let i of e.children)
    i instanceof I.TFolder
      ? await cn(i, n)
      : i instanceof I.TFile && i.extension === "md" && n.push(i);
}
var Hr = { tagFolderPath: "998_Tags", targetFolderPath: "" },
  ee = class extends F.Plugin {
    constructor() {
      super(...arguments);
      this.tagList = new Set();
    }
    async onload() {
      await this.loadSettings(),
        await this.generateTagList(),
        this.registerEvent(
          this.app.vault.on("create", (i) => {
            i instanceof F.TFile &&
              i.path.startsWith(this.settings.tagFolderPath) &&
              this.updateTagList(i, "add");
          })
        ),
        this.registerEvent(
          this.app.vault.on("rename", (i, l) => {
            var r;
            if (
              (i instanceof F.TFile &&
                i.path.startsWith(this.settings.tagFolderPath) &&
                this.updateTagList(i, "add"),
              l.startsWith(this.settings.tagFolderPath))
            ) {
              let t = H(
                ((r = l.split("/").pop()) == null
                  ? void 0
                  : r.replace(/\.md$/, "")) || ""
              );
              t && this.tagList.delete(t);
            }
          })
        ),
        this.registerEvent(
          this.app.vault.on("delete", (i) => {
            i instanceof F.TFile &&
              i.path.startsWith(this.settings.tagFolderPath) &&
              this.updateTagList(i, "remove");
          })
        ),
        this.addCommand({
          id: "auto-tag-and-link-current-file",
          name: "Auto Tag and Link: Current File",
          editorCallback: async (i, l) => {
            l.file &&
              (new F.Notice("Processing current file..."),
              await me(
                this.app,
                this.tagList,
                l.file,
                this.settings.targetFolderPath
              ),
              new F.Notice("Current file processed."));
          },
        }),
        this.addCommand({
          id: "auto-tag-and-link-target-folder",
          name: "Auto Tag and Link: Target Folder (or Vault)",
          callback: async () => {
            new F.Notice(
              `Processing files in "${
                this.settings.targetFolderPath || "the entire vault"
              }"...`
            ),
              await me(
                this.app,
                this.tagList,
                null,
                this.settings.targetFolderPath
              ),
              new F.Notice("All specified files processed.");
          },
        }),
        this.addSettingTab(new G(this.app, this));
    }
    onunload() {
      console.log("Unloading Auto Tag and Link Plugin");
    }
    async loadSettings() {
      this.settings = Object.assign({}, Hr, await this.loadData());
    }
    async saveSettings() {
      await this.saveData(this.settings);
    }
    async generateTagList() {
      this.tagList.clear();
      let i = this.app.vault.getAbstractFileByPath(this.settings.tagFolderPath);
      i instanceof F.TFolder
        ? (await this.walkFolder(i),
          new F.Notice(`Tags loaded: ${this.tagList.size} tags.`))
        : new F.Notice(
            `Tag folder "${this.settings.tagFolderPath}" not found. Please check plugin settings.`,
            5e3
          );
    }
    async walkFolder(i) {
      for (let l of i.children)
        if (l instanceof F.TFolder) await this.walkFolder(l);
        else if (l instanceof F.TFile && l.extension === "md") {
          let r = H(l.basename);
          r && this.tagList.add(r);
        }
    }
    updateTagList(i, l) {
      let r = H(i.basename);
      r &&
        (l === "add"
          ? this.tagList.add(r)
          : l === "remove" && this.tagList.delete(r));
    }
  };
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
